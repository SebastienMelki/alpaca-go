// Code generated by protoc-gen-go-client. DO NOT EDIT.
// source: alpaca/broker/v1/service.proto

package brokerv1

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"

	sebufhttp "github.com/SebastienMelki/sebuf/http"
)

const (
	// ContentTypeJSON is the content type for JSON requests/responses.
	ContentTypeJSON = "application/json"
	// ContentTypeProto is the content type for binary protobuf requests/responses.
	ContentTypeProto = "application/x-protobuf"
)

// BrokerServiceClient is the client API for BrokerService service.
type BrokerServiceClient interface {
	CreateAccount(ctx context.Context, req *CreateAccountRequest, opts ...BrokerServiceCallOption) (*BrokerAccount, error)
	ListAccounts(ctx context.Context, req *ListAccountsRequest, opts ...BrokerServiceCallOption) (*ListAccountsResponse, error)
	GetAccount(ctx context.Context, req *GetBrokerAccountRequest, opts ...BrokerServiceCallOption) (*BrokerAccount, error)
	UpdateAccount(ctx context.Context, req *UpdateBrokerAccountRequest, opts ...BrokerServiceCallOption) (*BrokerAccount, error)
	CloseAccount(ctx context.Context, req *CloseBrokerAccountRequest, opts ...BrokerServiceCallOption) (*CloseBrokerAccountResponse, error)
	CreateACHRelationship(ctx context.Context, req *CreateACHRelationshipRequest, opts ...BrokerServiceCallOption) (*ACHRelationship, error)
	ListACHRelationships(ctx context.Context, req *ListACHRelationshipsRequest, opts ...BrokerServiceCallOption) (*ListACHRelationshipsResponse, error)
	DeleteACHRelationship(ctx context.Context, req *DeleteACHRelationshipRequest, opts ...BrokerServiceCallOption) (*DeleteACHRelationshipResponse, error)
	CreateTransfer(ctx context.Context, req *CreateTransferRequest, opts ...BrokerServiceCallOption) (*Transfer, error)
	ListTransfers(ctx context.Context, req *ListTransfersRequest, opts ...BrokerServiceCallOption) (*ListTransfersResponse, error)
	GetTransfer(ctx context.Context, req *GetTransferRequest, opts ...BrokerServiceCallOption) (*Transfer, error)
	CancelTransfer(ctx context.Context, req *CancelTransferRequest, opts ...BrokerServiceCallOption) (*CancelTransferResponse, error)
	CreateTradingOrder(ctx context.Context, req *CreateTradingOrderRequest, opts ...BrokerServiceCallOption) (*BrokerOrder, error)
	ListTradingOrders(ctx context.Context, req *ListTradingOrdersRequest, opts ...BrokerServiceCallOption) (*ListTradingOrdersResponse, error)
	GetTradingOrder(ctx context.Context, req *GetTradingOrderRequest, opts ...BrokerServiceCallOption) (*BrokerOrder, error)
	CancelTradingOrder(ctx context.Context, req *CancelTradingOrderRequest, opts ...BrokerServiceCallOption) (*CancelTradingOrderResponse, error)
	ListTradingPositions(ctx context.Context, req *ListTradingPositionsRequest, opts ...BrokerServiceCallOption) (*ListTradingPositionsResponse, error)
	GetTradingPosition(ctx context.Context, req *GetTradingPositionRequest, opts ...BrokerServiceCallOption) (*BrokerPosition, error)
	CloseTradingPosition(ctx context.Context, req *CloseTradingPositionRequest, opts ...BrokerServiceCallOption) (*BrokerOrder, error)
	CloseAllTradingPositions(ctx context.Context, req *CloseAllTradingPositionsRequest, opts ...BrokerServiceCallOption) (*CloseAllTradingPositionsResponse, error)
}

// brokerServiceClient is the implementation of BrokerServiceClient.
type brokerServiceClient struct {
	baseURL        string
	httpClient     *http.Client
	contentType    string
	defaultHeaders map[string]string
}

var _ BrokerServiceClient = (*brokerServiceClient)(nil)

// BrokerServiceClientOption configures a BrokerService client.
type BrokerServiceClientOption func(*brokerServiceClient)

// WithBrokerServiceHTTPClient sets the HTTP client to use for requests.
func WithBrokerServiceHTTPClient(client *http.Client) BrokerServiceClientOption {
	return func(c *brokerServiceClient) {
		c.httpClient = client
	}
}

// WithBrokerServiceContentType sets the default content type for requests.
// Use ContentTypeJSON or ContentTypeProto.
func WithBrokerServiceContentType(contentType string) BrokerServiceClientOption {
	return func(c *brokerServiceClient) {
		c.contentType = contentType
	}
}

// WithBrokerServiceDefaultHeader sets a default header to include in all requests.
func WithBrokerServiceDefaultHeader(key, value string) BrokerServiceClientOption {
	return func(c *brokerServiceClient) {
		if c.defaultHeaders == nil {
			c.defaultHeaders = make(map[string]string)
		}
		c.defaultHeaders[key] = value
	}
}

// BrokerServiceCallOption configures a single RPC call.
type BrokerServiceCallOption func(*brokerServiceCallOptions)

// brokerServiceCallOptions holds options for a single RPC call.
type brokerServiceCallOptions struct {
	headers     map[string]string
	contentType string
}

// WithBrokerServiceHeader adds a header to a single request.
func WithBrokerServiceHeader(key, value string) BrokerServiceCallOption {
	return func(o *brokerServiceCallOptions) {
		if o.headers == nil {
			o.headers = make(map[string]string)
		}
		o.headers[key] = value
	}
}

// WithBrokerServiceCallContentType sets the content type for a single request.
func WithBrokerServiceCallContentType(contentType string) BrokerServiceCallOption {
	return func(o *brokerServiceCallOptions) {
		o.contentType = contentType
	}
}

// WithBrokerServiceAuthorization HTTP Basic Auth with base64 encoded API_KEY:API_SECRET
func WithBrokerServiceAuthorization(value string) BrokerServiceClientOption {
	return WithBrokerServiceDefaultHeader("Authorization", value)
}

// WithBrokerServiceCallAuthorization HTTP Basic Auth with base64 encoded API_KEY:API_SECRET for a single request.
func WithBrokerServiceCallAuthorization(value string) BrokerServiceCallOption {
	return WithBrokerServiceHeader("Authorization", value)
}

// NewBrokerServiceClient creates a new BrokerService client.
func NewBrokerServiceClient(baseURL string, opts ...BrokerServiceClientOption) BrokerServiceClient {
	c := &brokerServiceClient{
		baseURL:        strings.TrimSuffix(baseURL, "/"),
		httpClient:     http.DefaultClient,
		contentType:    ContentTypeJSON,
		defaultHeaders: make(map[string]string),
	}

	for _, opt := range opts {
		opt(c)
	}

	return c
}

// CreateAccount calls the CreateAccount RPC.
func (c *brokerServiceClient) CreateAccount(ctx context.Context, req *CreateAccountRequest, opts ...BrokerServiceCallOption) (*BrokerAccount, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/accounts"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &BrokerAccount{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// ListAccounts calls the ListAccounts RPC.
func (c *brokerServiceClient) ListAccounts(ctx context.Context, req *ListAccountsRequest, opts ...BrokerServiceCallOption) (*ListAccountsResponse, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/accounts"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Query != "" {
		queryParams.Set("query", fmt.Sprint(req.Query))
	}
	if req.CreatedAfter != "" {
		queryParams.Set("created_after", fmt.Sprint(req.CreatedAfter))
	}
	if req.CreatedBefore != "" {
		queryParams.Set("created_before", fmt.Sprint(req.CreatedBefore))
	}
	if req.Status != "" {
		queryParams.Set("status", fmt.Sprint(req.Status))
	}
	if req.Sort != "" {
		queryParams.Set("sort", fmt.Sprint(req.Sort))
	}
	if req.Entities != "" {
		queryParams.Set("entities", fmt.Sprint(req.Entities))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &ListAccountsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetAccount calls the GetAccount RPC.
func (c *brokerServiceClient) GetAccount(ctx context.Context, req *GetBrokerAccountRequest, opts ...BrokerServiceCallOption) (*BrokerAccount, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/accounts/{account_id}"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &BrokerAccount{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// UpdateAccount calls the UpdateAccount RPC.
func (c *brokerServiceClient) UpdateAccount(ctx context.Context, req *UpdateBrokerAccountRequest, opts ...BrokerServiceCallOption) (*BrokerAccount, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/accounts/{account_id}"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "PATCH", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &BrokerAccount{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// CloseAccount calls the CloseAccount RPC.
func (c *brokerServiceClient) CloseAccount(ctx context.Context, req *CloseBrokerAccountRequest, opts ...BrokerServiceCallOption) (*CloseBrokerAccountResponse, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/accounts/{account_id}"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &CloseBrokerAccountResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// CreateACHRelationship calls the CreateACHRelationship RPC.
func (c *brokerServiceClient) CreateACHRelationship(ctx context.Context, req *CreateACHRelationshipRequest, opts ...BrokerServiceCallOption) (*ACHRelationship, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/accounts/{account_id}/ach_relationships"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &ACHRelationship{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// ListACHRelationships calls the ListACHRelationships RPC.
func (c *brokerServiceClient) ListACHRelationships(ctx context.Context, req *ListACHRelationshipsRequest, opts ...BrokerServiceCallOption) (*ListACHRelationshipsResponse, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/accounts/{account_id}/ach_relationships"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Statuses != "" {
		queryParams.Set("statuses", fmt.Sprint(req.Statuses))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &ListACHRelationshipsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// DeleteACHRelationship calls the DeleteACHRelationship RPC.
func (c *brokerServiceClient) DeleteACHRelationship(ctx context.Context, req *DeleteACHRelationshipRequest, opts ...BrokerServiceCallOption) (*DeleteACHRelationshipResponse, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/accounts/{account_id}/ach_relationships/{ach_relationship_id}"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	path = strings.Replace(path, "{ach_relationship_id}", url.PathEscape(fmt.Sprint(req.AchRelationshipId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &DeleteACHRelationshipResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// CreateTransfer calls the CreateTransfer RPC.
func (c *brokerServiceClient) CreateTransfer(ctx context.Context, req *CreateTransferRequest, opts ...BrokerServiceCallOption) (*Transfer, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/accounts/{account_id}/transfers"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Transfer{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// ListTransfers calls the ListTransfers RPC.
func (c *brokerServiceClient) ListTransfers(ctx context.Context, req *ListTransfersRequest, opts ...BrokerServiceCallOption) (*ListTransfersResponse, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/accounts/{account_id}/transfers"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Direction != "" {
		queryParams.Set("direction", fmt.Sprint(req.Direction))
	}
	if req.Limit != 0 {
		queryParams.Set("limit", fmt.Sprint(req.Limit))
	}
	if req.Offset != 0 {
		queryParams.Set("offset", fmt.Sprint(req.Offset))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &ListTransfersResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetTransfer calls the GetTransfer RPC.
func (c *brokerServiceClient) GetTransfer(ctx context.Context, req *GetTransferRequest, opts ...BrokerServiceCallOption) (*Transfer, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/accounts/{account_id}/transfers/{transfer_id}"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	path = strings.Replace(path, "{transfer_id}", url.PathEscape(fmt.Sprint(req.TransferId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Transfer{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// CancelTransfer calls the CancelTransfer RPC.
func (c *brokerServiceClient) CancelTransfer(ctx context.Context, req *CancelTransferRequest, opts ...BrokerServiceCallOption) (*CancelTransferResponse, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/accounts/{account_id}/transfers/{transfer_id}"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	path = strings.Replace(path, "{transfer_id}", url.PathEscape(fmt.Sprint(req.TransferId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &CancelTransferResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// CreateTradingOrder calls the CreateTradingOrder RPC.
func (c *brokerServiceClient) CreateTradingOrder(ctx context.Context, req *CreateTradingOrderRequest, opts ...BrokerServiceCallOption) (*BrokerOrder, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/trading/accounts/{account_id}/orders"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &BrokerOrder{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// ListTradingOrders calls the ListTradingOrders RPC.
func (c *brokerServiceClient) ListTradingOrders(ctx context.Context, req *ListTradingOrdersRequest, opts ...BrokerServiceCallOption) (*ListTradingOrdersResponse, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/trading/accounts/{account_id}/orders"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Status != "" {
		queryParams.Set("status", fmt.Sprint(req.Status))
	}
	if req.Limit != 0 {
		queryParams.Set("limit", fmt.Sprint(req.Limit))
	}
	if req.After != "" {
		queryParams.Set("after", fmt.Sprint(req.After))
	}
	if req.Until != "" {
		queryParams.Set("until", fmt.Sprint(req.Until))
	}
	if req.Direction != "" {
		queryParams.Set("direction", fmt.Sprint(req.Direction))
	}
	if req.Nested != false {
		queryParams.Set("nested", fmt.Sprint(req.Nested))
	}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &ListTradingOrdersResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetTradingOrder calls the GetTradingOrder RPC.
func (c *brokerServiceClient) GetTradingOrder(ctx context.Context, req *GetTradingOrderRequest, opts ...BrokerServiceCallOption) (*BrokerOrder, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/trading/accounts/{account_id}/orders/{order_id}"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	path = strings.Replace(path, "{order_id}", url.PathEscape(fmt.Sprint(req.OrderId)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Nested != false {
		queryParams.Set("nested", fmt.Sprint(req.Nested))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &BrokerOrder{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// CancelTradingOrder calls the CancelTradingOrder RPC.
func (c *brokerServiceClient) CancelTradingOrder(ctx context.Context, req *CancelTradingOrderRequest, opts ...BrokerServiceCallOption) (*CancelTradingOrderResponse, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/trading/accounts/{account_id}/orders/{order_id}"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	path = strings.Replace(path, "{order_id}", url.PathEscape(fmt.Sprint(req.OrderId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &CancelTradingOrderResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// ListTradingPositions calls the ListTradingPositions RPC.
func (c *brokerServiceClient) ListTradingPositions(ctx context.Context, req *ListTradingPositionsRequest, opts ...BrokerServiceCallOption) (*ListTradingPositionsResponse, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/trading/accounts/{account_id}/positions"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &ListTradingPositionsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetTradingPosition calls the GetTradingPosition RPC.
func (c *brokerServiceClient) GetTradingPosition(ctx context.Context, req *GetTradingPositionRequest, opts ...BrokerServiceCallOption) (*BrokerPosition, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/trading/accounts/{account_id}/positions/{symbol}"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	path = strings.Replace(path, "{symbol}", url.PathEscape(fmt.Sprint(req.Symbol)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &BrokerPosition{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// CloseTradingPosition calls the CloseTradingPosition RPC.
func (c *brokerServiceClient) CloseTradingPosition(ctx context.Context, req *CloseTradingPositionRequest, opts ...BrokerServiceCallOption) (*BrokerOrder, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/trading/accounts/{account_id}/positions/{symbol}"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	path = strings.Replace(path, "{symbol}", url.PathEscape(fmt.Sprint(req.Symbol)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Qty != "" {
		queryParams.Set("qty", fmt.Sprint(req.Qty))
	}
	if req.Percentage != "" {
		queryParams.Set("percentage", fmt.Sprint(req.Percentage))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &BrokerOrder{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// CloseAllTradingPositions calls the CloseAllTradingPositions RPC.
func (c *brokerServiceClient) CloseAllTradingPositions(ctx context.Context, req *CloseAllTradingPositionsRequest, opts ...BrokerServiceCallOption) (*CloseAllTradingPositionsResponse, error) {
	callOpts := &brokerServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1/trading/accounts/{account_id}/positions"
	path = strings.Replace(path, "{account_id}", url.PathEscape(fmt.Sprint(req.AccountId)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.CancelOrders != false {
		queryParams.Set("cancel_orders", fmt.Sprint(req.CancelOrders))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &CloseAllTradingPositionsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

func (c *brokerServiceClient) marshalRequest(req proto.Message, contentType string) ([]byte, error) {
	switch contentType {
	case ContentTypeJSON:
		return protojson.Marshal(req)
	case ContentTypeProto:
		return proto.Marshal(req)
	default:
		return protojson.Marshal(req)
	}
}

func (c *brokerServiceClient) handleErrorResponse(statusCode int, body []byte, contentType string) error {
	// Try to parse as ValidationError first (for 400 errors)
	if statusCode == http.StatusBadRequest {
		validationErr := &sebufhttp.ValidationError{}
		if unmarshalErr := c.unmarshalResponse(body, validationErr, contentType); unmarshalErr == nil {
			return validationErr
		}
	}

	// Try to parse as generic Error
	genericErr := &sebufhttp.Error{}
	if unmarshalErr := c.unmarshalResponse(body, genericErr, contentType); unmarshalErr == nil {
		return genericErr
	}

	// Fallback to raw error message
	return fmt.Errorf("request failed with status %d: %s", statusCode, string(body))
}

func (c *brokerServiceClient) unmarshalResponse(body []byte, msg proto.Message, contentType string) error {
	if len(body) == 0 {
		return nil
	}

	switch contentType {
	case ContentTypeJSON:
		return protojson.Unmarshal(body, msg)
	case ContentTypeProto:
		return proto.Unmarshal(body, msg)
	default:
		return protojson.Unmarshal(body, msg)
	}
}
