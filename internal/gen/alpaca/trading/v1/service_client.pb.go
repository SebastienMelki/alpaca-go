// Code generated by protoc-gen-go-client. DO NOT EDIT.
// source: alpaca/trading/v1/service.proto

package tradingv1

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"

	sebufhttp "github.com/SebastienMelki/sebuf/http"
)

const (
	// ContentTypeJSON is the content type for JSON requests/responses.
	ContentTypeJSON = "application/json"
	// ContentTypeProto is the content type for binary protobuf requests/responses.
	ContentTypeProto = "application/x-protobuf"
)

// TradingServiceClient is the client API for TradingService service.
type TradingServiceClient interface {
	GetAccount(ctx context.Context, req *GetAccountRequest, opts ...TradingServiceCallOption) (*Account, error)
	GetAccountConfigurations(ctx context.Context, req *GetAccountConfigurationsRequest, opts ...TradingServiceCallOption) (*AccountConfigurations, error)
	UpdateAccountConfigurations(ctx context.Context, req *UpdateAccountConfigurationsRequest, opts ...TradingServiceCallOption) (*AccountConfigurations, error)
	GetPortfolioHistory(ctx context.Context, req *GetPortfolioHistoryRequest, opts ...TradingServiceCallOption) (*PortfolioHistory, error)
	GetAccountActivities(ctx context.Context, req *GetAccountActivitiesRequest, opts ...TradingServiceCallOption) (*GetAccountActivitiesResponse, error)
	GetAccountActivitiesByType(ctx context.Context, req *GetAccountActivitiesByTypeRequest, opts ...TradingServiceCallOption) (*GetAccountActivitiesResponse, error)
	CreateOrder(ctx context.Context, req *CreateOrderRequest, opts ...TradingServiceCallOption) (*Order, error)
	ListOrders(ctx context.Context, req *ListOrdersRequest, opts ...TradingServiceCallOption) (*ListOrdersResponse, error)
	GetOrder(ctx context.Context, req *GetOrderRequest, opts ...TradingServiceCallOption) (*Order, error)
	GetOrderByClientId(ctx context.Context, req *GetOrderByClientIdRequest, opts ...TradingServiceCallOption) (*Order, error)
	ReplaceOrder(ctx context.Context, req *ReplaceOrderRequest, opts ...TradingServiceCallOption) (*Order, error)
	CancelOrder(ctx context.Context, req *CancelOrderRequest, opts ...TradingServiceCallOption) (*CancelOrderResponse, error)
	CancelAllOrders(ctx context.Context, req *CancelAllOrdersRequest, opts ...TradingServiceCallOption) (*CancelAllOrdersResponse, error)
	ListPositions(ctx context.Context, req *ListPositionsRequest, opts ...TradingServiceCallOption) (*ListPositionsResponse, error)
	GetPosition(ctx context.Context, req *GetPositionRequest, opts ...TradingServiceCallOption) (*Position, error)
	ClosePosition(ctx context.Context, req *ClosePositionRequest, opts ...TradingServiceCallOption) (*Order, error)
	CloseAllPositions(ctx context.Context, req *CloseAllPositionsRequest, opts ...TradingServiceCallOption) (*CloseAllPositionsResponse, error)
	ExerciseOption(ctx context.Context, req *ExerciseOptionRequest, opts ...TradingServiceCallOption) (*ExerciseOptionResponse, error)
	ListAssets(ctx context.Context, req *ListAssetsRequest, opts ...TradingServiceCallOption) (*ListAssetsResponse, error)
	GetAsset(ctx context.Context, req *GetAssetRequest, opts ...TradingServiceCallOption) (*Asset, error)
	GetClock(ctx context.Context, req *GetClockRequest, opts ...TradingServiceCallOption) (*Clock, error)
	GetCalendar(ctx context.Context, req *GetCalendarRequest, opts ...TradingServiceCallOption) (*GetCalendarResponse, error)
	ListWatchlists(ctx context.Context, req *ListWatchlistsRequest, opts ...TradingServiceCallOption) (*ListWatchlistsResponse, error)
	CreateWatchlist(ctx context.Context, req *CreateWatchlistRequest, opts ...TradingServiceCallOption) (*Watchlist, error)
	GetWatchlist(ctx context.Context, req *GetWatchlistRequest, opts ...TradingServiceCallOption) (*Watchlist, error)
	UpdateWatchlist(ctx context.Context, req *UpdateWatchlistRequest, opts ...TradingServiceCallOption) (*Watchlist, error)
	DeleteWatchlist(ctx context.Context, req *DeleteWatchlistRequest, opts ...TradingServiceCallOption) (*DeleteWatchlistResponse, error)
	AddWatchlistAsset(ctx context.Context, req *AddWatchlistAssetRequest, opts ...TradingServiceCallOption) (*Watchlist, error)
	RemoveWatchlistAsset(ctx context.Context, req *RemoveWatchlistAssetRequest, opts ...TradingServiceCallOption) (*RemoveWatchlistAssetResponse, error)
}

// tradingServiceClient is the implementation of TradingServiceClient.
type tradingServiceClient struct {
	baseURL        string
	httpClient     *http.Client
	contentType    string
	defaultHeaders map[string]string
}

var _ TradingServiceClient = (*tradingServiceClient)(nil)

// TradingServiceClientOption configures a TradingService client.
type TradingServiceClientOption func(*tradingServiceClient)

// WithTradingServiceHTTPClient sets the HTTP client to use for requests.
func WithTradingServiceHTTPClient(client *http.Client) TradingServiceClientOption {
	return func(c *tradingServiceClient) {
		c.httpClient = client
	}
}

// WithTradingServiceContentType sets the default content type for requests.
// Use ContentTypeJSON or ContentTypeProto.
func WithTradingServiceContentType(contentType string) TradingServiceClientOption {
	return func(c *tradingServiceClient) {
		c.contentType = contentType
	}
}

// WithTradingServiceDefaultHeader sets a default header to include in all requests.
func WithTradingServiceDefaultHeader(key, value string) TradingServiceClientOption {
	return func(c *tradingServiceClient) {
		if c.defaultHeaders == nil {
			c.defaultHeaders = make(map[string]string)
		}
		c.defaultHeaders[key] = value
	}
}

// TradingServiceCallOption configures a single RPC call.
type TradingServiceCallOption func(*tradingServiceCallOptions)

// tradingServiceCallOptions holds options for a single RPC call.
type tradingServiceCallOptions struct {
	headers     map[string]string
	contentType string
}

// WithTradingServiceHeader adds a header to a single request.
func WithTradingServiceHeader(key, value string) TradingServiceCallOption {
	return func(o *tradingServiceCallOptions) {
		if o.headers == nil {
			o.headers = make(map[string]string)
		}
		o.headers[key] = value
	}
}

// WithTradingServiceCallContentType sets the content type for a single request.
func WithTradingServiceCallContentType(contentType string) TradingServiceCallOption {
	return func(o *tradingServiceCallOptions) {
		o.contentType = contentType
	}
}

// WithTradingServiceAPCAAPIKEYID Alpaca API key ID
func WithTradingServiceAPCAAPIKEYID(value string) TradingServiceClientOption {
	return WithTradingServiceDefaultHeader("APCA-API-KEY-ID", value)
}

// WithTradingServiceCallAPCAAPIKEYID Alpaca API key ID for a single request.
func WithTradingServiceCallAPCAAPIKEYID(value string) TradingServiceCallOption {
	return WithTradingServiceHeader("APCA-API-KEY-ID", value)
}

// WithTradingServiceAPCAAPISECRETKEY Alpaca API secret key
func WithTradingServiceAPCAAPISECRETKEY(value string) TradingServiceClientOption {
	return WithTradingServiceDefaultHeader("APCA-API-SECRET-KEY", value)
}

// WithTradingServiceCallAPCAAPISECRETKEY Alpaca API secret key for a single request.
func WithTradingServiceCallAPCAAPISECRETKEY(value string) TradingServiceCallOption {
	return WithTradingServiceHeader("APCA-API-SECRET-KEY", value)
}

// NewTradingServiceClient creates a new TradingService client.
func NewTradingServiceClient(baseURL string, opts ...TradingServiceClientOption) TradingServiceClient {
	c := &tradingServiceClient{
		baseURL:        strings.TrimSuffix(baseURL, "/"),
		httpClient:     http.DefaultClient,
		contentType:    ContentTypeJSON,
		defaultHeaders: make(map[string]string),
	}

	for _, opt := range opts {
		opt(c)
	}

	return c
}

// GetAccount calls the GetAccount RPC.
func (c *tradingServiceClient) GetAccount(ctx context.Context, req *GetAccountRequest, opts ...TradingServiceCallOption) (*Account, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/account"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Account{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetAccountConfigurations calls the GetAccountConfigurations RPC.
func (c *tradingServiceClient) GetAccountConfigurations(ctx context.Context, req *GetAccountConfigurationsRequest, opts ...TradingServiceCallOption) (*AccountConfigurations, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/account/configurations"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &AccountConfigurations{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// UpdateAccountConfigurations calls the UpdateAccountConfigurations RPC.
func (c *tradingServiceClient) UpdateAccountConfigurations(ctx context.Context, req *UpdateAccountConfigurationsRequest, opts ...TradingServiceCallOption) (*AccountConfigurations, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/account/configurations"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "PATCH", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &AccountConfigurations{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetPortfolioHistory calls the GetPortfolioHistory RPC.
func (c *tradingServiceClient) GetPortfolioHistory(ctx context.Context, req *GetPortfolioHistoryRequest, opts ...TradingServiceCallOption) (*PortfolioHistory, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/account/portfolio/history"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Period != "" {
		queryParams.Set("period", fmt.Sprint(req.Period))
	}
	if req.Timeframe != "" {
		queryParams.Set("timeframe", fmt.Sprint(req.Timeframe))
	}
	if req.IntradayReporting != "" {
		queryParams.Set("intraday_reporting", fmt.Sprint(req.IntradayReporting))
	}
	if req.Start != "" {
		queryParams.Set("start", fmt.Sprint(req.Start))
	}
	if req.End != "" {
		queryParams.Set("end", fmt.Sprint(req.End))
	}
	if req.PnlReset != false {
		queryParams.Set("pnl_reset", fmt.Sprint(req.PnlReset))
	}
	if req.ExtendedHours != false {
		queryParams.Set("extended_hours", fmt.Sprint(req.ExtendedHours))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &PortfolioHistory{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetAccountActivities calls the GetAccountActivities RPC.
func (c *tradingServiceClient) GetAccountActivities(ctx context.Context, req *GetAccountActivitiesRequest, opts ...TradingServiceCallOption) (*GetAccountActivitiesResponse, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/account/activities"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.ActivityType != "" {
		queryParams.Set("activity_type", fmt.Sprint(req.ActivityType))
	}
	if req.After != "" {
		queryParams.Set("after", fmt.Sprint(req.After))
	}
	if req.Until != "" {
		queryParams.Set("until", fmt.Sprint(req.Until))
	}
	if req.Direction != "" {
		queryParams.Set("direction", fmt.Sprint(req.Direction))
	}
	if req.PageSize != 0 {
		queryParams.Set("page_size", fmt.Sprint(req.PageSize))
	}
	if req.PageToken != "" {
		queryParams.Set("page_token", fmt.Sprint(req.PageToken))
	}
	if req.Date != "" {
		queryParams.Set("date", fmt.Sprint(req.Date))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetAccountActivitiesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetAccountActivitiesByType calls the GetAccountActivitiesByType RPC.
func (c *tradingServiceClient) GetAccountActivitiesByType(ctx context.Context, req *GetAccountActivitiesByTypeRequest, opts ...TradingServiceCallOption) (*GetAccountActivitiesResponse, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/account/activities/{activity_type}"
	path = strings.Replace(path, "{activity_type}", url.PathEscape(fmt.Sprint(req.ActivityType)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.After != "" {
		queryParams.Set("after", fmt.Sprint(req.After))
	}
	if req.Until != "" {
		queryParams.Set("until", fmt.Sprint(req.Until))
	}
	if req.Direction != "" {
		queryParams.Set("direction", fmt.Sprint(req.Direction))
	}
	if req.PageSize != 0 {
		queryParams.Set("page_size", fmt.Sprint(req.PageSize))
	}
	if req.PageToken != "" {
		queryParams.Set("page_token", fmt.Sprint(req.PageToken))
	}
	if req.Date != "" {
		queryParams.Set("date", fmt.Sprint(req.Date))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetAccountActivitiesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// CreateOrder calls the CreateOrder RPC.
func (c *tradingServiceClient) CreateOrder(ctx context.Context, req *CreateOrderRequest, opts ...TradingServiceCallOption) (*Order, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/orders"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Order{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// ListOrders calls the ListOrders RPC.
func (c *tradingServiceClient) ListOrders(ctx context.Context, req *ListOrdersRequest, opts ...TradingServiceCallOption) (*ListOrdersResponse, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/orders"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Status != "" {
		queryParams.Set("status", fmt.Sprint(req.Status))
	}
	if req.Limit != 0 {
		queryParams.Set("limit", fmt.Sprint(req.Limit))
	}
	if req.After != "" {
		queryParams.Set("after", fmt.Sprint(req.After))
	}
	if req.Until != "" {
		queryParams.Set("until", fmt.Sprint(req.Until))
	}
	if req.Direction != "" {
		queryParams.Set("direction", fmt.Sprint(req.Direction))
	}
	if req.Nested != false {
		queryParams.Set("nested", fmt.Sprint(req.Nested))
	}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Side != "" {
		queryParams.Set("side", fmt.Sprint(req.Side))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &ListOrdersResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetOrder calls the GetOrder RPC.
func (c *tradingServiceClient) GetOrder(ctx context.Context, req *GetOrderRequest, opts ...TradingServiceCallOption) (*Order, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/orders/{order_id}"
	path = strings.Replace(path, "{order_id}", url.PathEscape(fmt.Sprint(req.OrderId)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Nested != false {
		queryParams.Set("nested", fmt.Sprint(req.Nested))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Order{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetOrderByClientId calls the GetOrderByClientId RPC.
func (c *tradingServiceClient) GetOrderByClientId(ctx context.Context, req *GetOrderByClientIdRequest, opts ...TradingServiceCallOption) (*Order, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/orders:by_client_order_id"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.ClientOrderId != "" {
		queryParams.Set("client_order_id", fmt.Sprint(req.ClientOrderId))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Order{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// ReplaceOrder calls the ReplaceOrder RPC.
func (c *tradingServiceClient) ReplaceOrder(ctx context.Context, req *ReplaceOrderRequest, opts ...TradingServiceCallOption) (*Order, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/orders/{order_id}"
	path = strings.Replace(path, "{order_id}", url.PathEscape(fmt.Sprint(req.OrderId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "PATCH", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Order{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// CancelOrder calls the CancelOrder RPC.
func (c *tradingServiceClient) CancelOrder(ctx context.Context, req *CancelOrderRequest, opts ...TradingServiceCallOption) (*CancelOrderResponse, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/orders/{order_id}"
	path = strings.Replace(path, "{order_id}", url.PathEscape(fmt.Sprint(req.OrderId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &CancelOrderResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// CancelAllOrders calls the CancelAllOrders RPC.
func (c *tradingServiceClient) CancelAllOrders(ctx context.Context, req *CancelAllOrdersRequest, opts ...TradingServiceCallOption) (*CancelAllOrdersResponse, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/orders"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &CancelAllOrdersResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// ListPositions calls the ListPositions RPC.
func (c *tradingServiceClient) ListPositions(ctx context.Context, req *ListPositionsRequest, opts ...TradingServiceCallOption) (*ListPositionsResponse, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/positions"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &ListPositionsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetPosition calls the GetPosition RPC.
func (c *tradingServiceClient) GetPosition(ctx context.Context, req *GetPositionRequest, opts ...TradingServiceCallOption) (*Position, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/positions/{symbol}"
	path = strings.Replace(path, "{symbol}", url.PathEscape(fmt.Sprint(req.Symbol)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Position{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// ClosePosition calls the ClosePosition RPC.
func (c *tradingServiceClient) ClosePosition(ctx context.Context, req *ClosePositionRequest, opts ...TradingServiceCallOption) (*Order, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/positions/{symbol}"
	path = strings.Replace(path, "{symbol}", url.PathEscape(fmt.Sprint(req.Symbol)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Qty != "" {
		queryParams.Set("qty", fmt.Sprint(req.Qty))
	}
	if req.Percentage != "" {
		queryParams.Set("percentage", fmt.Sprint(req.Percentage))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Order{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// CloseAllPositions calls the CloseAllPositions RPC.
func (c *tradingServiceClient) CloseAllPositions(ctx context.Context, req *CloseAllPositionsRequest, opts ...TradingServiceCallOption) (*CloseAllPositionsResponse, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/positions"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.CancelOrders != false {
		queryParams.Set("cancel_orders", fmt.Sprint(req.CancelOrders))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &CloseAllPositionsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// ExerciseOption calls the ExerciseOption RPC.
func (c *tradingServiceClient) ExerciseOption(ctx context.Context, req *ExerciseOptionRequest, opts ...TradingServiceCallOption) (*ExerciseOptionResponse, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/positions/{symbol_or_contract_id}/exercise"
	path = strings.Replace(path, "{symbol_or_contract_id}", url.PathEscape(fmt.Sprint(req.SymbolOrContractId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &ExerciseOptionResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// ListAssets calls the ListAssets RPC.
func (c *tradingServiceClient) ListAssets(ctx context.Context, req *ListAssetsRequest, opts ...TradingServiceCallOption) (*ListAssetsResponse, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/assets"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Status != "" {
		queryParams.Set("status", fmt.Sprint(req.Status))
	}
	if req.AssetClass != "" {
		queryParams.Set("asset_class", fmt.Sprint(req.AssetClass))
	}
	if req.Exchange != "" {
		queryParams.Set("exchange", fmt.Sprint(req.Exchange))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &ListAssetsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetAsset calls the GetAsset RPC.
func (c *tradingServiceClient) GetAsset(ctx context.Context, req *GetAssetRequest, opts ...TradingServiceCallOption) (*Asset, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/assets/{symbol_or_id}"
	path = strings.Replace(path, "{symbol_or_id}", url.PathEscape(fmt.Sprint(req.SymbolOrId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Asset{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetClock calls the GetClock RPC.
func (c *tradingServiceClient) GetClock(ctx context.Context, req *GetClockRequest, opts ...TradingServiceCallOption) (*Clock, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/clock"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Clock{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetCalendar calls the GetCalendar RPC.
func (c *tradingServiceClient) GetCalendar(ctx context.Context, req *GetCalendarRequest, opts ...TradingServiceCallOption) (*GetCalendarResponse, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/calendar"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Start != "" {
		queryParams.Set("start", fmt.Sprint(req.Start))
	}
	if req.End != "" {
		queryParams.Set("end", fmt.Sprint(req.End))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetCalendarResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// ListWatchlists calls the ListWatchlists RPC.
func (c *tradingServiceClient) ListWatchlists(ctx context.Context, req *ListWatchlistsRequest, opts ...TradingServiceCallOption) (*ListWatchlistsResponse, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/watchlists"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &ListWatchlistsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// CreateWatchlist calls the CreateWatchlist RPC.
func (c *tradingServiceClient) CreateWatchlist(ctx context.Context, req *CreateWatchlistRequest, opts ...TradingServiceCallOption) (*Watchlist, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/watchlists"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Watchlist{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetWatchlist calls the GetWatchlist RPC.
func (c *tradingServiceClient) GetWatchlist(ctx context.Context, req *GetWatchlistRequest, opts ...TradingServiceCallOption) (*Watchlist, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/watchlists/{watchlist_id}"
	path = strings.Replace(path, "{watchlist_id}", url.PathEscape(fmt.Sprint(req.WatchlistId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Watchlist{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// UpdateWatchlist calls the UpdateWatchlist RPC.
func (c *tradingServiceClient) UpdateWatchlist(ctx context.Context, req *UpdateWatchlistRequest, opts ...TradingServiceCallOption) (*Watchlist, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/watchlists/{watchlist_id}"
	path = strings.Replace(path, "{watchlist_id}", url.PathEscape(fmt.Sprint(req.WatchlistId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "PUT", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Watchlist{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// DeleteWatchlist calls the DeleteWatchlist RPC.
func (c *tradingServiceClient) DeleteWatchlist(ctx context.Context, req *DeleteWatchlistRequest, opts ...TradingServiceCallOption) (*DeleteWatchlistResponse, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/watchlists/{watchlist_id}"
	path = strings.Replace(path, "{watchlist_id}", url.PathEscape(fmt.Sprint(req.WatchlistId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &DeleteWatchlistResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// AddWatchlistAsset calls the AddWatchlistAsset RPC.
func (c *tradingServiceClient) AddWatchlistAsset(ctx context.Context, req *AddWatchlistAssetRequest, opts ...TradingServiceCallOption) (*Watchlist, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/watchlists/{watchlist_id}"
	path = strings.Replace(path, "{watchlist_id}", url.PathEscape(fmt.Sprint(req.WatchlistId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Watchlist{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// RemoveWatchlistAsset calls the RemoveWatchlistAsset RPC.
func (c *tradingServiceClient) RemoveWatchlistAsset(ctx context.Context, req *RemoveWatchlistAssetRequest, opts ...TradingServiceCallOption) (*RemoveWatchlistAssetResponse, error) {
	callOpts := &tradingServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/watchlists/{watchlist_id}/{symbol}"
	path = strings.Replace(path, "{watchlist_id}", url.PathEscape(fmt.Sprint(req.WatchlistId)), 1)
	path = strings.Replace(path, "{symbol}", url.PathEscape(fmt.Sprint(req.Symbol)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &RemoveWatchlistAssetResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

func (c *tradingServiceClient) marshalRequest(req proto.Message, contentType string) ([]byte, error) {
	switch contentType {
	case ContentTypeJSON:
		return protojson.Marshal(req)
	case ContentTypeProto:
		return proto.Marshal(req)
	default:
		return protojson.Marshal(req)
	}
}

func (c *tradingServiceClient) handleErrorResponse(statusCode int, body []byte, contentType string) error {
	// Try to parse as ValidationError first (for 400 errors)
	if statusCode == http.StatusBadRequest {
		validationErr := &sebufhttp.ValidationError{}
		if unmarshalErr := c.unmarshalResponse(body, validationErr, contentType); unmarshalErr == nil {
			return validationErr
		}
	}

	// Try to parse as generic Error
	genericErr := &sebufhttp.Error{}
	if unmarshalErr := c.unmarshalResponse(body, genericErr, contentType); unmarshalErr == nil {
		return genericErr
	}

	// Fallback to raw error message
	return fmt.Errorf("request failed with status %d: %s", statusCode, string(body))
}

func (c *tradingServiceClient) unmarshalResponse(body []byte, msg proto.Message, contentType string) error {
	if len(body) == 0 {
		return nil
	}

	switch contentType {
	case ContentTypeJSON:
		return protojson.Unmarshal(body, msg)
	case ContentTypeProto:
		return proto.Unmarshal(body, msg)
	default:
		return protojson.Unmarshal(body, msg)
	}
}
