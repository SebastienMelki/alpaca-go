// Code generated by protoc-gen-go-client. DO NOT EDIT.
// source: alpaca/marketdata/v2/service.proto

package marketdatav2

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"

	sebufhttp "github.com/SebastienMelki/sebuf/http"
)

const (
	// ContentTypeJSON is the content type for JSON requests/responses.
	ContentTypeJSON = "application/json"
	// ContentTypeProto is the content type for binary protobuf requests/responses.
	ContentTypeProto = "application/x-protobuf"
)

// MarketDataServiceClient is the client API for MarketDataService service.
type MarketDataServiceClient interface {
	GetStockBars(ctx context.Context, req *GetStockBarsRequest, opts ...MarketDataServiceCallOption) (*GetStockBarsResponse, error)
	GetLatestStockBars(ctx context.Context, req *GetLatestStockBarsRequest, opts ...MarketDataServiceCallOption) (*GetLatestStockBarsResponse, error)
	GetStockTrades(ctx context.Context, req *GetStockTradesRequest, opts ...MarketDataServiceCallOption) (*GetStockTradesResponse, error)
	GetLatestStockTrades(ctx context.Context, req *GetLatestStockTradesRequest, opts ...MarketDataServiceCallOption) (*GetLatestStockTradesResponse, error)
	GetStockQuotes(ctx context.Context, req *GetStockQuotesRequest, opts ...MarketDataServiceCallOption) (*GetStockQuotesResponse, error)
	GetLatestStockQuotes(ctx context.Context, req *GetLatestStockQuotesRequest, opts ...MarketDataServiceCallOption) (*GetLatestStockQuotesResponse, error)
	GetStockSnapshots(ctx context.Context, req *GetStockSnapshotsRequest, opts ...MarketDataServiceCallOption) (*GetStockSnapshotsResponse, error)
	GetStockSnapshot(ctx context.Context, req *GetStockSnapshotRequest, opts ...MarketDataServiceCallOption) (*Snapshot, error)
	GetStockAuctions(ctx context.Context, req *GetStockAuctionsRequest, opts ...MarketDataServiceCallOption) (*GetStockAuctionsResponse, error)
	GetCryptoBars(ctx context.Context, req *GetCryptoBarsRequest, opts ...MarketDataServiceCallOption) (*GetCryptoBarsResponse, error)
	GetLatestCryptoBars(ctx context.Context, req *GetLatestCryptoBarsRequest, opts ...MarketDataServiceCallOption) (*GetLatestCryptoBarsResponse, error)
	GetCryptoTrades(ctx context.Context, req *GetCryptoTradesRequest, opts ...MarketDataServiceCallOption) (*GetCryptoTradesResponse, error)
	GetLatestCryptoTrades(ctx context.Context, req *GetLatestCryptoTradesRequest, opts ...MarketDataServiceCallOption) (*GetLatestCryptoTradesResponse, error)
	GetCryptoQuotes(ctx context.Context, req *GetCryptoQuotesRequest, opts ...MarketDataServiceCallOption) (*GetCryptoQuotesResponse, error)
	GetLatestCryptoQuotes(ctx context.Context, req *GetLatestCryptoQuotesRequest, opts ...MarketDataServiceCallOption) (*GetLatestCryptoQuotesResponse, error)
	GetCryptoSnapshots(ctx context.Context, req *GetCryptoSnapshotsRequest, opts ...MarketDataServiceCallOption) (*GetCryptoSnapshotsResponse, error)
	GetOptionBars(ctx context.Context, req *GetOptionBarsRequest, opts ...MarketDataServiceCallOption) (*GetOptionBarsResponse, error)
	GetLatestOptionBars(ctx context.Context, req *GetLatestOptionBarsRequest, opts ...MarketDataServiceCallOption) (*GetLatestOptionBarsResponse, error)
	GetOptionTrades(ctx context.Context, req *GetOptionTradesRequest, opts ...MarketDataServiceCallOption) (*GetOptionTradesResponse, error)
	GetLatestOptionTrades(ctx context.Context, req *GetLatestOptionTradesRequest, opts ...MarketDataServiceCallOption) (*GetLatestOptionTradesResponse, error)
	GetOptionQuotes(ctx context.Context, req *GetOptionQuotesRequest, opts ...MarketDataServiceCallOption) (*GetOptionQuotesResponse, error)
	GetLatestOptionQuotes(ctx context.Context, req *GetLatestOptionQuotesRequest, opts ...MarketDataServiceCallOption) (*GetLatestOptionQuotesResponse, error)
	GetOptionSnapshots(ctx context.Context, req *GetOptionSnapshotsRequest, opts ...MarketDataServiceCallOption) (*GetOptionSnapshotsResponse, error)
	GetOptionChain(ctx context.Context, req *GetOptionChainRequest, opts ...MarketDataServiceCallOption) (*GetOptionChainResponse, error)
	GetNews(ctx context.Context, req *GetNewsRequest, opts ...MarketDataServiceCallOption) (*GetNewsResponse, error)
	GetMostActives(ctx context.Context, req *GetMostActivesRequest, opts ...MarketDataServiceCallOption) (*GetMostActivesResponse, error)
	GetMovers(ctx context.Context, req *GetMoversRequest, opts ...MarketDataServiceCallOption) (*GetMoversResponse, error)
}

// marketDataServiceClient is the implementation of MarketDataServiceClient.
type marketDataServiceClient struct {
	baseURL        string
	httpClient     *http.Client
	contentType    string
	defaultHeaders map[string]string
}

var _ MarketDataServiceClient = (*marketDataServiceClient)(nil)

// MarketDataServiceClientOption configures a MarketDataService client.
type MarketDataServiceClientOption func(*marketDataServiceClient)

// WithMarketDataServiceHTTPClient sets the HTTP client to use for requests.
func WithMarketDataServiceHTTPClient(client *http.Client) MarketDataServiceClientOption {
	return func(c *marketDataServiceClient) {
		c.httpClient = client
	}
}

// WithMarketDataServiceContentType sets the default content type for requests.
// Use ContentTypeJSON or ContentTypeProto.
func WithMarketDataServiceContentType(contentType string) MarketDataServiceClientOption {
	return func(c *marketDataServiceClient) {
		c.contentType = contentType
	}
}

// WithMarketDataServiceDefaultHeader sets a default header to include in all requests.
func WithMarketDataServiceDefaultHeader(key, value string) MarketDataServiceClientOption {
	return func(c *marketDataServiceClient) {
		if c.defaultHeaders == nil {
			c.defaultHeaders = make(map[string]string)
		}
		c.defaultHeaders[key] = value
	}
}

// MarketDataServiceCallOption configures a single RPC call.
type MarketDataServiceCallOption func(*marketDataServiceCallOptions)

// marketDataServiceCallOptions holds options for a single RPC call.
type marketDataServiceCallOptions struct {
	headers     map[string]string
	contentType string
}

// WithMarketDataServiceHeader adds a header to a single request.
func WithMarketDataServiceHeader(key, value string) MarketDataServiceCallOption {
	return func(o *marketDataServiceCallOptions) {
		if o.headers == nil {
			o.headers = make(map[string]string)
		}
		o.headers[key] = value
	}
}

// WithMarketDataServiceCallContentType sets the content type for a single request.
func WithMarketDataServiceCallContentType(contentType string) MarketDataServiceCallOption {
	return func(o *marketDataServiceCallOptions) {
		o.contentType = contentType
	}
}

// WithMarketDataServiceAPCAAPIKEYID Alpaca API key ID
func WithMarketDataServiceAPCAAPIKEYID(value string) MarketDataServiceClientOption {
	return WithMarketDataServiceDefaultHeader("APCA-API-KEY-ID", value)
}

// WithMarketDataServiceCallAPCAAPIKEYID Alpaca API key ID for a single request.
func WithMarketDataServiceCallAPCAAPIKEYID(value string) MarketDataServiceCallOption {
	return WithMarketDataServiceHeader("APCA-API-KEY-ID", value)
}

// WithMarketDataServiceAPCAAPISECRETKEY Alpaca API secret key
func WithMarketDataServiceAPCAAPISECRETKEY(value string) MarketDataServiceClientOption {
	return WithMarketDataServiceDefaultHeader("APCA-API-SECRET-KEY", value)
}

// WithMarketDataServiceCallAPCAAPISECRETKEY Alpaca API secret key for a single request.
func WithMarketDataServiceCallAPCAAPISECRETKEY(value string) MarketDataServiceCallOption {
	return WithMarketDataServiceHeader("APCA-API-SECRET-KEY", value)
}

// NewMarketDataServiceClient creates a new MarketDataService client.
func NewMarketDataServiceClient(baseURL string, opts ...MarketDataServiceClientOption) MarketDataServiceClient {
	c := &marketDataServiceClient{
		baseURL:        strings.TrimSuffix(baseURL, "/"),
		httpClient:     http.DefaultClient,
		contentType:    ContentTypeJSON,
		defaultHeaders: make(map[string]string),
	}

	for _, opt := range opts {
		opt(c)
	}

	return c
}

// GetStockBars calls the GetStockBars RPC.
func (c *marketDataServiceClient) GetStockBars(ctx context.Context, req *GetStockBarsRequest, opts ...MarketDataServiceCallOption) (*GetStockBarsResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/stocks/bars"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Timeframe != "" {
		queryParams.Set("timeframe", fmt.Sprint(req.Timeframe))
	}
	if req.Start != "" {
		queryParams.Set("start", fmt.Sprint(req.Start))
	}
	if req.End != "" {
		queryParams.Set("end", fmt.Sprint(req.End))
	}
	if req.Limit != 0 {
		queryParams.Set("limit", fmt.Sprint(req.Limit))
	}
	if req.Adjustment != "" {
		queryParams.Set("adjustment", fmt.Sprint(req.Adjustment))
	}
	if req.Feed != "" {
		queryParams.Set("feed", fmt.Sprint(req.Feed))
	}
	if req.PageToken != "" {
		queryParams.Set("page_token", fmt.Sprint(req.PageToken))
	}
	if req.Sort != "" {
		queryParams.Set("sort", fmt.Sprint(req.Sort))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetStockBarsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetLatestStockBars calls the GetLatestStockBars RPC.
func (c *marketDataServiceClient) GetLatestStockBars(ctx context.Context, req *GetLatestStockBarsRequest, opts ...MarketDataServiceCallOption) (*GetLatestStockBarsResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/stocks/bars/latest"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Feed != "" {
		queryParams.Set("feed", fmt.Sprint(req.Feed))
	}
	if req.Currency != "" {
		queryParams.Set("currency", fmt.Sprint(req.Currency))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetLatestStockBarsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetStockTrades calls the GetStockTrades RPC.
func (c *marketDataServiceClient) GetStockTrades(ctx context.Context, req *GetStockTradesRequest, opts ...MarketDataServiceCallOption) (*GetStockTradesResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/stocks/trades"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Start != "" {
		queryParams.Set("start", fmt.Sprint(req.Start))
	}
	if req.End != "" {
		queryParams.Set("end", fmt.Sprint(req.End))
	}
	if req.Limit != 0 {
		queryParams.Set("limit", fmt.Sprint(req.Limit))
	}
	if req.Feed != "" {
		queryParams.Set("feed", fmt.Sprint(req.Feed))
	}
	if req.PageToken != "" {
		queryParams.Set("page_token", fmt.Sprint(req.PageToken))
	}
	if req.Sort != "" {
		queryParams.Set("sort", fmt.Sprint(req.Sort))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetStockTradesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetLatestStockTrades calls the GetLatestStockTrades RPC.
func (c *marketDataServiceClient) GetLatestStockTrades(ctx context.Context, req *GetLatestStockTradesRequest, opts ...MarketDataServiceCallOption) (*GetLatestStockTradesResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/stocks/trades/latest"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Feed != "" {
		queryParams.Set("feed", fmt.Sprint(req.Feed))
	}
	if req.Currency != "" {
		queryParams.Set("currency", fmt.Sprint(req.Currency))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetLatestStockTradesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetStockQuotes calls the GetStockQuotes RPC.
func (c *marketDataServiceClient) GetStockQuotes(ctx context.Context, req *GetStockQuotesRequest, opts ...MarketDataServiceCallOption) (*GetStockQuotesResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/stocks/quotes"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Start != "" {
		queryParams.Set("start", fmt.Sprint(req.Start))
	}
	if req.End != "" {
		queryParams.Set("end", fmt.Sprint(req.End))
	}
	if req.Limit != 0 {
		queryParams.Set("limit", fmt.Sprint(req.Limit))
	}
	if req.Feed != "" {
		queryParams.Set("feed", fmt.Sprint(req.Feed))
	}
	if req.PageToken != "" {
		queryParams.Set("page_token", fmt.Sprint(req.PageToken))
	}
	if req.Sort != "" {
		queryParams.Set("sort", fmt.Sprint(req.Sort))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetStockQuotesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetLatestStockQuotes calls the GetLatestStockQuotes RPC.
func (c *marketDataServiceClient) GetLatestStockQuotes(ctx context.Context, req *GetLatestStockQuotesRequest, opts ...MarketDataServiceCallOption) (*GetLatestStockQuotesResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/stocks/quotes/latest"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Feed != "" {
		queryParams.Set("feed", fmt.Sprint(req.Feed))
	}
	if req.Currency != "" {
		queryParams.Set("currency", fmt.Sprint(req.Currency))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetLatestStockQuotesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetStockSnapshots calls the GetStockSnapshots RPC.
func (c *marketDataServiceClient) GetStockSnapshots(ctx context.Context, req *GetStockSnapshotsRequest, opts ...MarketDataServiceCallOption) (*GetStockSnapshotsResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/stocks/snapshots"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Feed != "" {
		queryParams.Set("feed", fmt.Sprint(req.Feed))
	}
	if req.Currency != "" {
		queryParams.Set("currency", fmt.Sprint(req.Currency))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetStockSnapshotsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetStockSnapshot calls the GetStockSnapshot RPC.
func (c *marketDataServiceClient) GetStockSnapshot(ctx context.Context, req *GetStockSnapshotRequest, opts ...MarketDataServiceCallOption) (*Snapshot, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/stocks/{symbol}/snapshot"
	path = strings.Replace(path, "{symbol}", url.PathEscape(fmt.Sprint(req.Symbol)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Feed != "" {
		queryParams.Set("feed", fmt.Sprint(req.Feed))
	}
	if req.Currency != "" {
		queryParams.Set("currency", fmt.Sprint(req.Currency))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Snapshot{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetStockAuctions calls the GetStockAuctions RPC.
func (c *marketDataServiceClient) GetStockAuctions(ctx context.Context, req *GetStockAuctionsRequest, opts ...MarketDataServiceCallOption) (*GetStockAuctionsResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v2/stocks/auctions"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Start != "" {
		queryParams.Set("start", fmt.Sprint(req.Start))
	}
	if req.End != "" {
		queryParams.Set("end", fmt.Sprint(req.End))
	}
	if req.Limit != 0 {
		queryParams.Set("limit", fmt.Sprint(req.Limit))
	}
	if req.PageToken != "" {
		queryParams.Set("page_token", fmt.Sprint(req.PageToken))
	}
	if req.Sort != "" {
		queryParams.Set("sort", fmt.Sprint(req.Sort))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetStockAuctionsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetCryptoBars calls the GetCryptoBars RPC.
func (c *marketDataServiceClient) GetCryptoBars(ctx context.Context, req *GetCryptoBarsRequest, opts ...MarketDataServiceCallOption) (*GetCryptoBarsResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta3/crypto/{loc}/bars"
	path = strings.Replace(path, "{loc}", url.PathEscape(fmt.Sprint(req.Loc)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Timeframe != "" {
		queryParams.Set("timeframe", fmt.Sprint(req.Timeframe))
	}
	if req.Start != "" {
		queryParams.Set("start", fmt.Sprint(req.Start))
	}
	if req.End != "" {
		queryParams.Set("end", fmt.Sprint(req.End))
	}
	if req.Limit != 0 {
		queryParams.Set("limit", fmt.Sprint(req.Limit))
	}
	if req.PageToken != "" {
		queryParams.Set("page_token", fmt.Sprint(req.PageToken))
	}
	if req.Sort != "" {
		queryParams.Set("sort", fmt.Sprint(req.Sort))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetCryptoBarsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetLatestCryptoBars calls the GetLatestCryptoBars RPC.
func (c *marketDataServiceClient) GetLatestCryptoBars(ctx context.Context, req *GetLatestCryptoBarsRequest, opts ...MarketDataServiceCallOption) (*GetLatestCryptoBarsResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta3/crypto/{loc}/latest/bars"
	path = strings.Replace(path, "{loc}", url.PathEscape(fmt.Sprint(req.Loc)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetLatestCryptoBarsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetCryptoTrades calls the GetCryptoTrades RPC.
func (c *marketDataServiceClient) GetCryptoTrades(ctx context.Context, req *GetCryptoTradesRequest, opts ...MarketDataServiceCallOption) (*GetCryptoTradesResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta3/crypto/{loc}/trades"
	path = strings.Replace(path, "{loc}", url.PathEscape(fmt.Sprint(req.Loc)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Start != "" {
		queryParams.Set("start", fmt.Sprint(req.Start))
	}
	if req.End != "" {
		queryParams.Set("end", fmt.Sprint(req.End))
	}
	if req.Limit != 0 {
		queryParams.Set("limit", fmt.Sprint(req.Limit))
	}
	if req.PageToken != "" {
		queryParams.Set("page_token", fmt.Sprint(req.PageToken))
	}
	if req.Sort != "" {
		queryParams.Set("sort", fmt.Sprint(req.Sort))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetCryptoTradesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetLatestCryptoTrades calls the GetLatestCryptoTrades RPC.
func (c *marketDataServiceClient) GetLatestCryptoTrades(ctx context.Context, req *GetLatestCryptoTradesRequest, opts ...MarketDataServiceCallOption) (*GetLatestCryptoTradesResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta3/crypto/{loc}/latest/trades"
	path = strings.Replace(path, "{loc}", url.PathEscape(fmt.Sprint(req.Loc)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetLatestCryptoTradesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetCryptoQuotes calls the GetCryptoQuotes RPC.
func (c *marketDataServiceClient) GetCryptoQuotes(ctx context.Context, req *GetCryptoQuotesRequest, opts ...MarketDataServiceCallOption) (*GetCryptoQuotesResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta3/crypto/{loc}/quotes"
	path = strings.Replace(path, "{loc}", url.PathEscape(fmt.Sprint(req.Loc)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Start != "" {
		queryParams.Set("start", fmt.Sprint(req.Start))
	}
	if req.End != "" {
		queryParams.Set("end", fmt.Sprint(req.End))
	}
	if req.Limit != 0 {
		queryParams.Set("limit", fmt.Sprint(req.Limit))
	}
	if req.PageToken != "" {
		queryParams.Set("page_token", fmt.Sprint(req.PageToken))
	}
	if req.Sort != "" {
		queryParams.Set("sort", fmt.Sprint(req.Sort))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetCryptoQuotesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetLatestCryptoQuotes calls the GetLatestCryptoQuotes RPC.
func (c *marketDataServiceClient) GetLatestCryptoQuotes(ctx context.Context, req *GetLatestCryptoQuotesRequest, opts ...MarketDataServiceCallOption) (*GetLatestCryptoQuotesResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta3/crypto/{loc}/latest/quotes"
	path = strings.Replace(path, "{loc}", url.PathEscape(fmt.Sprint(req.Loc)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetLatestCryptoQuotesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetCryptoSnapshots calls the GetCryptoSnapshots RPC.
func (c *marketDataServiceClient) GetCryptoSnapshots(ctx context.Context, req *GetCryptoSnapshotsRequest, opts ...MarketDataServiceCallOption) (*GetCryptoSnapshotsResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta3/crypto/{loc}/snapshots"
	path = strings.Replace(path, "{loc}", url.PathEscape(fmt.Sprint(req.Loc)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetCryptoSnapshotsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetOptionBars calls the GetOptionBars RPC.
func (c *marketDataServiceClient) GetOptionBars(ctx context.Context, req *GetOptionBarsRequest, opts ...MarketDataServiceCallOption) (*GetOptionBarsResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta1/options/bars"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Timeframe != "" {
		queryParams.Set("timeframe", fmt.Sprint(req.Timeframe))
	}
	if req.Start != "" {
		queryParams.Set("start", fmt.Sprint(req.Start))
	}
	if req.End != "" {
		queryParams.Set("end", fmt.Sprint(req.End))
	}
	if req.Limit != 0 {
		queryParams.Set("limit", fmt.Sprint(req.Limit))
	}
	if req.PageToken != "" {
		queryParams.Set("page_token", fmt.Sprint(req.PageToken))
	}
	if req.Sort != "" {
		queryParams.Set("sort", fmt.Sprint(req.Sort))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetOptionBarsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetLatestOptionBars calls the GetLatestOptionBars RPC.
func (c *marketDataServiceClient) GetLatestOptionBars(ctx context.Context, req *GetLatestOptionBarsRequest, opts ...MarketDataServiceCallOption) (*GetLatestOptionBarsResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta1/options/bars/latest"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Feed != "" {
		queryParams.Set("feed", fmt.Sprint(req.Feed))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetLatestOptionBarsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetOptionTrades calls the GetOptionTrades RPC.
func (c *marketDataServiceClient) GetOptionTrades(ctx context.Context, req *GetOptionTradesRequest, opts ...MarketDataServiceCallOption) (*GetOptionTradesResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta1/options/trades"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Start != "" {
		queryParams.Set("start", fmt.Sprint(req.Start))
	}
	if req.End != "" {
		queryParams.Set("end", fmt.Sprint(req.End))
	}
	if req.Limit != 0 {
		queryParams.Set("limit", fmt.Sprint(req.Limit))
	}
	if req.PageToken != "" {
		queryParams.Set("page_token", fmt.Sprint(req.PageToken))
	}
	if req.Sort != "" {
		queryParams.Set("sort", fmt.Sprint(req.Sort))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetOptionTradesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetLatestOptionTrades calls the GetLatestOptionTrades RPC.
func (c *marketDataServiceClient) GetLatestOptionTrades(ctx context.Context, req *GetLatestOptionTradesRequest, opts ...MarketDataServiceCallOption) (*GetLatestOptionTradesResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta1/options/trades/latest"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Feed != "" {
		queryParams.Set("feed", fmt.Sprint(req.Feed))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetLatestOptionTradesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetOptionQuotes calls the GetOptionQuotes RPC.
func (c *marketDataServiceClient) GetOptionQuotes(ctx context.Context, req *GetOptionQuotesRequest, opts ...MarketDataServiceCallOption) (*GetOptionQuotesResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta1/options/quotes"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Start != "" {
		queryParams.Set("start", fmt.Sprint(req.Start))
	}
	if req.End != "" {
		queryParams.Set("end", fmt.Sprint(req.End))
	}
	if req.Limit != 0 {
		queryParams.Set("limit", fmt.Sprint(req.Limit))
	}
	if req.PageToken != "" {
		queryParams.Set("page_token", fmt.Sprint(req.PageToken))
	}
	if req.Sort != "" {
		queryParams.Set("sort", fmt.Sprint(req.Sort))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetOptionQuotesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetLatestOptionQuotes calls the GetLatestOptionQuotes RPC.
func (c *marketDataServiceClient) GetLatestOptionQuotes(ctx context.Context, req *GetLatestOptionQuotesRequest, opts ...MarketDataServiceCallOption) (*GetLatestOptionQuotesResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta1/options/quotes/latest"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Feed != "" {
		queryParams.Set("feed", fmt.Sprint(req.Feed))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetLatestOptionQuotesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetOptionSnapshots calls the GetOptionSnapshots RPC.
func (c *marketDataServiceClient) GetOptionSnapshots(ctx context.Context, req *GetOptionSnapshotsRequest, opts ...MarketDataServiceCallOption) (*GetOptionSnapshotsResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta1/options/snapshots"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Feed != "" {
		queryParams.Set("feed", fmt.Sprint(req.Feed))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetOptionSnapshotsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetOptionChain calls the GetOptionChain RPC.
func (c *marketDataServiceClient) GetOptionChain(ctx context.Context, req *GetOptionChainRequest, opts ...MarketDataServiceCallOption) (*GetOptionChainResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta1/options/snapshots/{underlying_symbol}"
	path = strings.Replace(path, "{underlying_symbol}", url.PathEscape(fmt.Sprint(req.UnderlyingSymbol)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Feed != "" {
		queryParams.Set("feed", fmt.Sprint(req.Feed))
	}
	if req.Type != "" {
		queryParams.Set("type", fmt.Sprint(req.Type))
	}
	if req.StrikePriceGte != 0 {
		queryParams.Set("strike_price_gte", fmt.Sprint(req.StrikePriceGte))
	}
	if req.StrikePriceLte != 0 {
		queryParams.Set("strike_price_lte", fmt.Sprint(req.StrikePriceLte))
	}
	if req.ExpirationDateGte != "" {
		queryParams.Set("expiration_date_gte", fmt.Sprint(req.ExpirationDateGte))
	}
	if req.ExpirationDateLte != "" {
		queryParams.Set("expiration_date_lte", fmt.Sprint(req.ExpirationDateLte))
	}
	if req.PageToken != "" {
		queryParams.Set("page_token", fmt.Sprint(req.PageToken))
	}
	if req.Limit != 0 {
		queryParams.Set("limit", fmt.Sprint(req.Limit))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetOptionChainResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetNews calls the GetNews RPC.
func (c *marketDataServiceClient) GetNews(ctx context.Context, req *GetNewsRequest, opts ...MarketDataServiceCallOption) (*GetNewsResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta1/news"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Symbols != "" {
		queryParams.Set("symbols", fmt.Sprint(req.Symbols))
	}
	if req.Start != "" {
		queryParams.Set("start", fmt.Sprint(req.Start))
	}
	if req.End != "" {
		queryParams.Set("end", fmt.Sprint(req.End))
	}
	if req.Limit != 0 {
		queryParams.Set("limit", fmt.Sprint(req.Limit))
	}
	if req.Sort != "" {
		queryParams.Set("sort", fmt.Sprint(req.Sort))
	}
	if req.IncludeContent != false {
		queryParams.Set("include_content", fmt.Sprint(req.IncludeContent))
	}
	if req.PageToken != "" {
		queryParams.Set("page_token", fmt.Sprint(req.PageToken))
	}
	if req.ExcludeContentless != false {
		queryParams.Set("exclude_contentless", fmt.Sprint(req.ExcludeContentless))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetNewsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetMostActives calls the GetMostActives RPC.
func (c *marketDataServiceClient) GetMostActives(ctx context.Context, req *GetMostActivesRequest, opts ...MarketDataServiceCallOption) (*GetMostActivesResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta1/screener/stocks/most-actives"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Top != 0 {
		queryParams.Set("top", fmt.Sprint(req.Top))
	}
	if req.By != "" {
		queryParams.Set("by", fmt.Sprint(req.By))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetMostActivesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetMovers calls the GetMovers RPC.
func (c *marketDataServiceClient) GetMovers(ctx context.Context, req *GetMoversRequest, opts ...MarketDataServiceCallOption) (*GetMoversResponse, error) {
	callOpts := &marketDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/v1beta1/screener/{market_type}/movers"
	path = strings.Replace(path, "{market_type}", url.PathEscape(fmt.Sprint(req.MarketType)), 1)
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Top != 0 {
		queryParams.Set("top", fmt.Sprint(req.Top))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetMoversResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

func (c *marketDataServiceClient) marshalRequest(req proto.Message, contentType string) ([]byte, error) {
	switch contentType {
	case ContentTypeJSON:
		return protojson.Marshal(req)
	case ContentTypeProto:
		return proto.Marshal(req)
	default:
		return protojson.Marshal(req)
	}
}

func (c *marketDataServiceClient) handleErrorResponse(statusCode int, body []byte, contentType string) error {
	// Try to parse as ValidationError first (for 400 errors)
	if statusCode == http.StatusBadRequest {
		validationErr := &sebufhttp.ValidationError{}
		if unmarshalErr := c.unmarshalResponse(body, validationErr, contentType); unmarshalErr == nil {
			return validationErr
		}
	}

	// Try to parse as generic Error
	genericErr := &sebufhttp.Error{}
	if unmarshalErr := c.unmarshalResponse(body, genericErr, contentType); unmarshalErr == nil {
		return genericErr
	}

	// Fallback to raw error message
	return fmt.Errorf("request failed with status %d: %s", statusCode, string(body))
}

func (c *marketDataServiceClient) unmarshalResponse(body []byte, msg proto.Message, contentType string) error {
	if len(body) == 0 {
		return nil
	}

	switch contentType {
	case ContentTypeJSON:
		return protojson.Unmarshal(body, msg)
	case ContentTypeProto:
		return proto.Unmarshal(body, msg)
	default:
		return protojson.Unmarshal(body, msg)
	}
}
