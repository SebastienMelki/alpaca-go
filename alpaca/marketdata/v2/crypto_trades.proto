syntax = "proto3";

package alpaca.marketdata.v2;

import "buf/validate/validate.proto";
import "sebuf/http/annotations.proto";

// CryptoTrade represents a crypto trade.
message CryptoTrade {
  // Timestamp (RFC 3339).
  string t = 1 [(sebuf.http.field_examples) = { values: ["2024-01-15T10:30:00.123456Z"] }];

  // Trade price.
  double p = 2 [(sebuf.http.field_examples) = { values: ["42000.00"] }];

  // Trade size.
  double s = 3 [(sebuf.http.field_examples) = { values: ["0.5"] }];

  // Trade ID.
  int64 i = 4 [(sebuf.http.field_examples) = { values: ["12345678901"] }];

  // Taker side (B = buy, S = sell).
  string tks = 5 [(sebuf.http.field_examples) = { values: ["B"] }];
}

// GetCryptoTradesRequest is the request to get historical crypto trades.
message GetCryptoTradesRequest {
  // Crypto location (us).
  string loc = 1 [(sebuf.http.field_examples) = { values: ["us"] }];

  // Comma-separated list of symbols.
  string symbols = 2 [
    (buf.validate.field).required = true,
    (sebuf.http.query) = { name: "symbols" },
    (sebuf.http.field_examples) = { values: ["BTC/USD,ETH/USD"] }
  ];

  // Start timestamp (RFC 3339 or YYYY-MM-DD).
  string start = 3 [
    (sebuf.http.query) = { name: "start" },
    (sebuf.http.field_examples) = { values: ["2024-01-15T00:00:00Z"] }
  ];

  // End timestamp (RFC 3339 or YYYY-MM-DD).
  string end = 4 [
    (sebuf.http.query) = { name: "end" },
    (sebuf.http.field_examples) = { values: ["2024-01-15T23:59:59Z"] }
  ];

  // Maximum number of trades to return (1-10000, default 1000).
  int32 limit = 5 [
    (sebuf.http.query) = { name: "limit" },
    (buf.validate.field).int32 = { gte: 1, lte: 10000 },
    (sebuf.http.field_examples) = { values: ["1000"] }
  ];

  // Page token for pagination.
  string page_token = 6 [
    (sebuf.http.query) = { name: "page_token" },
    (sebuf.http.field_examples) = { values: ["token123"] }
  ];

  // Sort order (asc, desc).
  string sort = 7 [
    (sebuf.http.query) = { name: "sort" },
    (sebuf.http.field_examples) = { values: ["asc"] }
  ];
}

// CryptoTradesList is a list of trades for a single symbol.
message CryptoTradesList {
  repeated CryptoTrade trades = 1;
}

// GetCryptoTradesResponse is the response containing crypto trades.
message GetCryptoTradesResponse {
  // Map of symbol to trades.
  map<string, CryptoTradesList> trades = 1;

  // Next page token.
  string next_page_token = 2 [(sebuf.http.field_examples) = { values: ["YWJjZGVm"] }];
}

// GetLatestCryptoTradesRequest is the request to get the latest crypto trades.
message GetLatestCryptoTradesRequest {
  // Crypto location (us).
  string loc = 1 [(sebuf.http.field_examples) = { values: ["us"] }];

  // Comma-separated list of symbols.
  string symbols = 2 [
    (buf.validate.field).required = true,
    (sebuf.http.query) = { name: "symbols" },
    (sebuf.http.field_examples) = { values: ["BTC/USD,ETH/USD"] }
  ];
}

// GetLatestCryptoTradesResponse is the response containing the latest crypto trades.
message GetLatestCryptoTradesResponse {
  // Map of symbol to latest trade.
  map<string, CryptoTrade> trades = 1;
}
